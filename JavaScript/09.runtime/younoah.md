## 프로세스와 쓰레드

### 프로세스 (프로그래밍의 최고 동작 단위)

- 컴퓨터(운영체제) 위에서 연속적으로 실행되고 있는 프로그램을 말한다.

- 각각의 프로세스는 서로 독립적으로 메모리 위에서 실행 되고 있다.

- 따라서 하나의 프로세스가 죽는다고 해서 다른 프로세스에 영향을 끼치지는 않는다.
- 각각의 프로세스마다 자신만의 리소스들이 할당되어있다. 
- 리소스는 code, stack, heap, data를 말한다.
	- code : 프로그램을 실행하기 위한 코드가 저장되어 있는 메모리 공간
	- stack : 함수의 실행 순서와 정보를 저장하는 메모리 공간
	- heap : 오브젝트 생성시 저장되는 메모리 공간 (동적 할당 변수)
	- data : 전역변수, static변수가 할당되는 공간



### 쓰레드 (프로세스 안에서의 일꾼)

- 프로세스 안에서 저마다 해야 되는 업무를 수행한다. (한 마디로 일꾼)
- 하나의 프로세스 안에서 여러개가 동작할 수 있다. (멀티쓰레드, 멀티쓰레딩)
- 쓰레드는 자기들만의 수행해야하는 함수의 호출, 순서(흐름)을 기억해야하기 때문에 쓰레드마다 스택이 할당되어있다.
- 이런 쓰레드 덕분에 하나의 프로세스안에서 여러개의 쓰레드를 만들어 여러가지 일을 동시 다발적으로 수행할 수 있다.

- 쓰레드는 프로세스의 자원(리소스: 코드, 힙, 데이터)를 공통적으로 접근한다. 즉, 여러개의 쓰레드가 하나의 프로세스 자원을 공유한다.
- 자원을 공유하기 때문에 잘못하면 자원의 업데이트가 꼬여서 예상치 못한 오류가 발생할 수 있다.



## 자바스크립트 런타임 환경

#### in 자바

- 멀티쓰레딩 가능
- 쓰레드별로 동작 및 다양한 설정 가능

#### in 자바스크립트

- 자바스크립트 언어 자체는 싱글스레드
- 브라우저는 web apis를 활용하여 멀티쓰레딩 가능
- 하지만 자바스크립트는 브라우저 위에서 돌아가기 때문에 web apis를 활용하여 멀티쓰레딩을 구현

> 자바같은 경우 멀티쓰레딩을 지원하기 때문에 예를들어 쓰레드a에서는 데이터를 불러오고 쓰레드b에서는 다른 동작을 하는식으로 각각 지정해서 프로그래밍을 짤 수 있고 총 몇개의 쓰레드가 동시에 동작할 수 있는지 등 다양한것들을 활용할 수 있다.
>
> 하지만 자바스크립트는 **'Single Threaded Language'** 이다. 따라서 언어 자체에는 멀티쓰레딩을 할 수 없다. 그래서 자바처럼 어떤 일은 쓰레드a에서 다른일은 쓰레드b에서 각가 지정할 수 있는 방법이 전혀 없다.
>
> 하지만 자바스크립트가 동작하고 있는 브라우저 위에서는 즉 브라우저 프로그램 안에서는 여러가지의 쓰레드가 들어있다. 그래서 웹 APIs들을 이용하게 되면 멀티쓰레딩이 가능하다.
>
> 또한 자바스크립트가 동작하는 런타임 환경에서는 다양한 방식을 이용해서 멀티쓰레딩 같은 효과를 얻을수도 있다.
>
> 그리고 런타임 환경에서 **'이벤트 루프'**를 이용해서 조금 더 다양한 동작을 실행할 수 있다.



## 자바스크립트 엔진

![runtime1](/Users/uno/Desktop/runtime1.png)

작성한 웹 어플리케이션을 브라우저에 올리는 순간 자바스크립트 엔진이 코드를 한 줄 한줄씩 해석하고 분석하고 실행하게 된다.

자바스크립트 엔진에는 메모리 힙과 콜 스택이 존재한다. (프로세스안에 힙과 스택이 존재하듯, 웹 브라우저 엔진이라는 프로세스안에 힙과 스택이 존재한다.)

### 메모리 힙

메모리 힙에는 변수를 선언해서 객체를 할당하거나 문자열, 숫자등을 할당하게 되면 이 데이터들이 전부 메모리 힙에 저장이 된다. 그리고 메모리 힙은 구조적으로 정리된 자료구조가 아닌 자료들이 여기저기에 아무곳에나 저장되어있다.

### 콜스택

콜 스택은 함수를 실행하는 순서에 따라서 차곡 차곡 쌓아놓고 스택방식으로 함수를 실행한다.

### Web APIs

브라우저에서 제공해주는 API들을 활용해서 멀티쓰레딩을 구현할 수 있다. (브라우저는 멀티쓰레딩이 가능하다.) 대표적으로 fetch를 이용해서 데이터를 받아온다던지, setTiemout을 이용해서 일정 시간이 지난 다음에 콜백함수를 실행하는 등의 멀티쓰레딩을 할 수 있다.



## 자바스크립트 엔진과 Web APIs가 협업하는 방법

자바스크립트 엔진은 콜스택에 함수를 순서대로 실행한다. 그럼 이때 웹APIs와 콜백함수를 어떻게 동작할까? 즉, 웹APIs와 자바스크립트 엔진이 어떻게 협업할까?



![runtime2](/Users/uno/Desktop/runtime2.png)

### 콜스택

자바스크립트의 함수를 순서대로 쌓아서 실행하는 역할

### 태스크큐

웹 APIs의 콜백함수가 대기하는 곳

> EventListener
>
> fetch
>
> setTimeOut, setInterval

### 마이크로 태스크큐

''프로미스의 then'과 'mutation observer'에 등록된 콜백함수들이 대기하는 곳

### 렌더 시퀀스

> 리퀘스트 애니메이션 프레임 → 렌더트리 → 레이아웃 → 페인트

브라우저에서 코드에 따라 주기적으로 업데이트 되기 위해서 호출되는 순서 (렌더링 프로세스!)

렌더링 프로세스 이전에 **'리퀘스트 애니메이션 프레임(RAF)(큐방식)'**이라는 API를 호출하면 이 API에 등록한 콜백함수가 큐에 차곡차곡 쌓여저서 실행된다.



### 이벤트 루프

이벤트 루프는 위에서 언급한 렌더, 마이크로 태스크큐, 태스크 큐, 콜 스택들을 순회하면서 각각의 상황들에 맞게 처리한다.

##### - 콜스택

이벤트 루프는 콜스택에 바라보고 있을때 콜스택이 비워질 계속 콜스택에서 대기한다. 콜스택이 비워젔을 때 이벤트 루프는 다시 순회를 시작한다.

콜스택에 무한루프에 빠지면(스택오버플로우) 이벤트루프가 계속 콜스택만 바라보고 있기 때문에 렌더링을 더이상 하지 않게되어 마치 렉이 걸린듯 브라우저가 멈추게 된다.



##### - 태스크큐 (web apis)

이벤트 루프가 태스크큐를 바라볼 때 태스크큐에서 콜스택으로 딱 하나의 콜백함수만 넘긴 뒤 순회를 이어간다.

태스크 큐에는 무한히 쌓여도 이벤트 루프는 하나씩만 넘기고 순회를 하기 때문에 렌더링이 멈추지 않기 때문에 브라우저가 멈추어 보이지는 않는다.



##### - 마이크로 태스크큐 (프로미스, mutation observer)

이벤트루프가 마이크로 태스크큐 를 바로볼 때 마이크로 태스큐에 쌓여있는 콜백함수를 하나하나씩 콜스택으로 보낸다. 태스큐와 달리 콜스택에 넘긴 콜백함수가 종료되면 곧바로 다음 콜백함수를 넘기는 식으로 마이크로태스크큐에 있는 모든 콜백함수를 처리할 때까지 바라본다.

마이크로 태스크큐에 무한히 쌓이면 이벤트루프는 계속 마이크로 태스크큐를 바라보기 때문에 브라우저는 멈추게된다.



##### - 렌더 시퀀스

이벤트 루프는 순회를 할 때마다 렌더 시쿼스를 바라보는 것은 아니다. 60fps(1초에 60개 프레임을 보여주기위함), 즉 약 16.7ms 주기로 렌더 시퀀스를 바라본다.

처음에는 '리퀘스트 애니메이션 프레임(RAF)' 부터 큐 방식으로 처리하고 렌더링 프로세스를 진행한다.



## 코드로 보는 이벤트 루프

#### 

```javascript
// 상황1
const btn = document.querySelector('button');

btn.addEventListener('click', () => {
    const elem = document.createElement('h1');
    document.body.append(elem);
    elem.style.color = 'red';
    elem.style.innerText = 'hello'
})

// 상황2
const btn = document.querySelector('button');
const box = document.querySelector('.box');
btn.addEventListener('click', () => {
	box.style.transition = 'transform 1s ease-in';
    box.style.transform = 'translateX(800px)';
    box.style.transfrom = 'translateX(500px)'
})
```



상황1에서 요소에 스타일을 우선 지정하고 append를 해야 문제가 없을 것 같지만 사실 코드 순서는 상관이없다.

상황2에서는 800px 이동후 500px 이동을 노리고 구현했겠지만 결과적으로 한번에 움직이게 된다.

해당 콜백함수가 콜스택에서 모두 실행이 완료된 이후에 이벤트루프가 진행되어 렌더 시퀀스에서 렌더링이 진행되기 때문이다.



## 참고하면 좋은 자료

https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=PLpjvGpURp3yjz_OYVkXdTq1TXX2P9SCbl&index=58&t=1416s